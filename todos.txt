================================================================================
CreditTimeline (ctview2) - Implementation Roadmap
================================================================================

This file tracks the full implementation timeline for the CreditTimeline app.
Future LLM sessions should read this file to understand what's been done and
what comes next.
It should represent the current status of the project and you must keep this document up to date at all times.

Whenever you complete a task in this list you must mark it as completed with a x in the box.
When an entire phase is completed mark the phase as completed in the phase heading. 
The user will move the completed tasks to todos-completed.txt (do not consume this document unless you require historical context on why something was done)

Whenever designing or implementing features or functionality or bug fixes the below ADRs must be respected and complied with.
================================================================================
ARCHITECTURE DECISIONS
================================================================================

AD-001: TypeScript full-stack with SvelteKit
  - Single language across backend and frontend
  - SvelteKit serves both API routes and UI from one process
  - adapter-node for Docker deployment

AD-002: Drizzle ORM with dialect-switching pattern
  - SQLite (better-sqlite3) as default/reference storage
  - Postgres support planned via parallel schema definitions
  - Schema-as-code matches spec SQL DDL exactly

AD-003: Ajv for JSON Schema validation
  - Draft 2020-12 with cross-file $ref support
  - Compiled validator for fast repeated validation
  - Two schema files: main schema + enums

AD-004: pnpm monorepo with two packages
  - @ctview/core: pure TS library (no web deps)
  - @ctview/web: SvelteKit application
  - Core can be imported by future CLI tools

AD-005: Single Docker container by default
  - SQLite volume mount for data persistence
  - Optional Postgres sidecar via compose override
  - Multi-stage build for small image size

AD-006: No authentication by default
  - Personal vault, network-level access control
  - Optional INGEST_API_KEY for ingestion endpoint
  - CSRF via SvelteKit's built-in origin checking

AD-007: API-first design for external client support
  - SvelteKit API routes are the canonical interface for all data operations
  - All /api/v1/* routes MUST return JSON and work for any HTTP client (mobile
    apps, CLI tools, third-party integrations, browser fetch)
  - The full container (including frontend) is the deployment unit — external
    clients connect to the same running instance
  - CORS must be configurable so cross-origin clients can call the API
  - All API routes must have consistent error response shapes, proper HTTP
    status codes, and be documented via OpenAPI spec
  - API versioning via URL prefix (/api/v1/) is already in place — maintain
    this convention for all future endpoints
  - SvelteKit page load functions (+page.server.ts) should call the same query
    logic that API routes use, ensuring feature parity between the UI and
    external consumers. Shared query functions should live in @ctview/core or
    a shared lib, not be duplicated between page loads and API routes
  - Future: a lightweight @ctview/sdk package can wrap the HTTP API for
    TypeScript consumers

AD-008: Zod for runtime validation at system boundaries
  - Ajv handles JSON Schema validation of credit file payloads (AD-003)
  - Zod handles everything else at runtime boundaries:
    - Environment variable parsing and validation at startup
    - API request body/query parameter validation
    - Configuration object shapes
    - Response type narrowing
  - This dual-validation approach gives the best of both worlds:
    - Ajv for spec-compliant schema validation (JSON Schema draft 2020-12)
    - Zod for ergonomic TypeScript-native validation with inference


================================================================================
PHASE 7: ANALYSIS & INSIGHTS  ✅ COMPLETED
================================================================================

[x] Anomaly detection rule engine
    [x] Design a pluggable rule architecture:
        - Each rule is a function: (db, importContext) → InsightResult[]
        - Rules run automatically after successful ingestion
        - Each rule returns zero or more generated_insight records
        - Rules are registered in a central array and executed sequentially
        - New rules can be added without modifying the orchestrator
    [x] Severity classification for all generated insights:
        - info: Informational, no action needed (e.g. "new tradeline opened")
        - low: Minor observation (e.g. "address changed between imports")
        - medium: Warrants attention (e.g. "hard search from unknown org")
        - high: Requires investigation (e.g. "large unexpected balance jump",
          "payment status degraded to default")
    [x] Entity linking for all insights:
        - Every generated_insight links to the relevant entities via
          generated_insight_entity join table
        - Enables "show me all anomalies for this tradeline" queries

[x] Core anomaly rules
    [x] Hard search detection
        - Flag hard searches appearing since last import
        - Classify by frequency: occasional (low), frequent (medium),
          burst pattern (high)
        - Cross-reference search organisation against known tradeline lenders
          to distinguish expected searches (you applied) from unexpected ones
    [x] Payment status degradation
        - Compare tradeline payment_status between consecutive snapshots
        - Flag any worsening (e.g. current → 1-month-late → 3-months-late)
        - Severity scales with degradation magnitude
    [x] Unexpected balance changes
        - Flag balance increases/decreases that exceed a configurable threshold
          percentage between consecutive snapshots
        - Useful for spotting unauthorized charges or data errors
    [x] New tradeline detection
        - Flag tradelines appearing for the first time in an import
        - Distinguish between expected (new account) and unexpected
    [x] Status changes
        - Flag tradeline status transitions (active → settled, active → default)
        - Credit score movements exceeding threshold
    [x] Cross-agency discrepancy detection
        - Compare tradeline data reported by different agencies for the same
          account (matched via canonical_id)
        - Flag material differences in balance, limit, or status

[x] Trend analysis
    [ ] Debt-to-income trend (if income data available) — deferred, requires income data not in schema
    [x] Credit utilization trend
    [x] Score movement correlation with account events
[x] Generated insights pipeline
    [x] Quality warnings (missing data, sparse imports) — done in Phase 2
    [x] Cross-agency comparison insights — covered by cross-agency discrepancy rule
    [x] Payment pattern analysis

================================================================================
PHASE 8: POSTGRES SUPPORT
================================================================================

[ ] Create parallel Drizzle schema (packages/core/src/schema/pg/)
[ ] Dialect-switching database factory
[ ] Postgres-specific migration runner
[ ] Test full pipeline against Postgres
[ ] Update Docker compose for production Postgres usage

================================================================================
PHASE 9: POLISH & PRODUCTION
================================================================================

[ ] API documentation — OpenAPI spec (AD-007)
    [ ] Generate an OpenAPI 3.1 specification for all /api/v1/* routes
    [ ] Options for generation:
        - Manual: maintain a spec/openapi.yaml file updated as routes change
        - Auto: use a library to generate spec from route definitions (e.g.
          sveltekit-openapi or a custom Zod-to-OpenAPI pipeline)
    [ ] Serve the OpenAPI spec at GET /api/v1/openapi.json
    [ ] Optionally serve Swagger UI or Scalar at /api/docs for interactive
        API exploration
    [ ] The spec should be accurate enough that external clients can generate
        typed client code from it

[ ] Client SDK package (AD-007)
    [ ] Create @ctview/sdk package in the monorepo
    [ ] Lightweight TypeScript HTTP client wrapping all /api/v1/* endpoints
    [ ] Type-safe request/response types (shared with or generated from the
        API's Zod schemas)
    [ ] Zero runtime dependencies beyond fetch (works in Node, browser, Deno)
    [ ] Publish as npm package (or just use via workspace dependency)
    [ ] This enables external TypeScript consumers to integrate without
        hand-crafting HTTP calls

[ ] Authentication (optional, for multi-user households)
[ ] Data export (JSON, CSV)
    [ ] Export full credit file as JSON (reversible, re-importable)
    [ ] Export tradeline/search/score data as CSV
    [ ] Export dashboard as printable HTML or PDF
[ ] Backup/restore tooling
    [ ] SQLite: file-level backup with VACUUM INTO for consistent snapshots
    [ ] Postgres: pg_dump wrapper
    [ ] Restore command with validation
[ ] Rate limiting on ingestion endpoint
[ ] Comprehensive error pages
[ ] Mobile-responsive layout
[ ] Performance optimization (pagination, lazy loading)
[ ] Accessibility audit (WCAG 2.1 AA)
[ ] End-to-end Playwright test suite
[ ] CI/CD pipeline (GitHub Actions)
    [ ] Lint + format check
    [ ] Type check (svelte-check + tsc)
    [ ] Unit tests (vitest)
    [ ] E2E tests (playwright)
    [ ] Docker build verification
    [ ] Automated release tagging
[ ] User documentation (setup guide, API guide, troubleshooting)
[ ] Data retention policies
    [ ] Configurable max age for raw artifacts
    [ ] Archive vs. delete semantics
    [ ] Compact old audit_log entries

================================================================================
FUTURE IDEAS (UNSCHEDULED)
================================================================================

- CLI tool for importing credit reports from command line
  (this is a key motivator for @ctview/core being framework-independent)
- Browser extension for scraping credit reports directly
- PDF parser adapter (Equifax statutory report)
- HTML scraper adapter (TransUnion via ClearScore)
- Notification system (email/webhook on score changes)
- Multi-subject support (household members)
- Plugin system for custom analysis
- Mobile app consuming the API (AD-007 ensures API is ready for this)
- Import diff view: side-by-side comparison showing what changed between
  two consecutive imports for the same subject (new tradelines, closed
  accounts, balance movements, score changes)
- GraphQL layer alongside REST (for clients that prefer it)
- Webhook system: push notifications to external URLs when anomalies are
  detected or new imports are processed
