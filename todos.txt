================================================================================
CreditTimeline (ctview2) - Implementation Roadmap
================================================================================

This file tracks the full implementation timeline for the CreditTimeline app.
Future LLM sessions should read this file to understand what's been done and
what comes next.
It should represent the current status of the project and you must keep this document up to date at all times.

Whenever you complete a task in this list you must mark it as completed with a x in the box.
When an entire phase is completed mark the phase as completed in the phase heading. 

Whenever designing or implementing features or functionality or bug fixes the below ADRs must be respected and complied with.
================================================================================
ARCHITECTURE DECISIONS
================================================================================

AD-001: TypeScript full-stack with SvelteKit
  - Single language across backend and frontend
  - SvelteKit serves both API routes and UI from one process
  - adapter-node for Docker deployment

AD-002: Drizzle ORM with dialect-switching pattern
  - SQLite (better-sqlite3) as default/reference storage
  - Postgres support planned via parallel schema definitions
  - Schema-as-code matches spec SQL DDL exactly

AD-003: Ajv for JSON Schema validation
  - Draft 2020-12 with cross-file $ref support
  - Compiled validator for fast repeated validation
  - Two schema files: main schema + enums

AD-004: pnpm monorepo with two packages
  - @ctview/core: pure TS library (no web deps)
  - @ctview/web: SvelteKit application
  - Core can be imported by future CLI tools

AD-005: Single Docker container by default
  - SQLite volume mount for data persistence
  - Optional Postgres sidecar via compose override
  - Multi-stage build for small image size

AD-006: No authentication by default
  - Personal vault, network-level access control
  - Optional INGEST_API_KEY for ingestion endpoint
  - CSRF via SvelteKit's built-in origin checking

AD-007: API-first design for external client support
  - SvelteKit API routes are the canonical interface for all data operations
  - All /api/v1/* routes MUST return JSON and work for any HTTP client (mobile
    apps, CLI tools, third-party integrations, browser fetch)
  - The full container (including frontend) is the deployment unit — external
    clients connect to the same running instance
  - CORS must be configurable so cross-origin clients can call the API
  - All API routes must have consistent error response shapes, proper HTTP
    status codes, and be documented via OpenAPI spec
  - API versioning via URL prefix (/api/v1/) is already in place — maintain
    this convention for all future endpoints
  - SvelteKit page load functions (+page.server.ts) should call the same query
    logic that API routes use, ensuring feature parity between the UI and
    external consumers. Shared query functions should live in @ctview/core or
    a shared lib, not be duplicated between page loads and API routes
  - Future: a lightweight @ctview/sdk package can wrap the HTTP API for
    TypeScript consumers

AD-008: Zod for runtime validation at system boundaries
  - Ajv handles JSON Schema validation of credit file payloads (AD-003)
  - Zod handles everything else at runtime boundaries:
    - Environment variable parsing and validation at startup
    - API request body/query parameter validation
    - Configuration object shapes
    - Response type narrowing
  - This dual-validation approach gives the best of both worlds:
    - Ajv for spec-compliant schema validation (JSON Schema draft 2020-12)
    - Zod for ergonomic TypeScript-native validation with inference

================================================================================
PHASE 1: SCAFFOLDING (COMPLETE)
================================================================================

[x] Initialize pnpm monorepo (package.json, workspace, tsconfig)
[x] Vendor spec files (schemas, SQL, mappings, examples)
[x] Scaffold @ctview/core package
    [x] Drizzle SQLite schema for all 30 tables
    [x] Drizzle relations declarations
    [x] Database client factory
    [x] Database migration runner
    [x] Ajv JSON Schema validator
    [x] Ingestion pipeline stub
    [x] TypeScript enum types
    [x] Canonical transport types
[x] Scaffold @ctview/web package
    [x] SvelteKit with adapter-node
    [x] Tailwind CSS setup
    [x] App shell layout (sidebar + content)
    [x] Dashboard page with summary cards
    [x] Placeholder routes for all sections
    [x] POST /api/v1/ingest endpoint
    [x] GET /api/v1/health endpoint
    [x] hooks.server.ts (DB init, API key middleware)
[x] Docker setup
    [x] Multi-stage Dockerfile
    [x] docker-compose.yml (SQLite)
    [x] docker-compose.postgres.yml (Postgres override)
[x] Create todos.txt (this file)

================================================================================
PHASE 1B: DEVELOPER TOOLING & API FOUNDATION (COMPLETE)
================================================================================

This phase establishes code quality tooling and API infrastructure that all
subsequent phases depend on. It should be completed before Phase 2.

[x] Code quality tooling
    [x] ESLint configuration
        - Install eslint + @typescript-eslint/parser + @typescript-eslint/eslint-plugin
        - Use flat config format (eslint.config.js) as this is the modern standard
        - Enable recommended + typescript-eslint recommended rules
        - Enforce consistent type imports (type keyword for type-only imports)
        - Configure for both .ts and .svelte files (eslint-plugin-svelte)
        - Root config shared across both packages
    [x] Prettier configuration
        - Install prettier + prettier-plugin-svelte + prettier-plugin-tailwindcss
        - Create .prettierrc.json in project root
        - Recommended: semicolons, single quotes, trailing commas, 100-char width
        - Ensure Prettier and ESLint do not conflict (eslint-config-prettier)
    [x] Add lint/format scripts to root package.json
        - "lint": runs ESLint across all packages
        - "lint:fix": auto-fix ESLint issues
        - "format": check formatting with Prettier
        - "format:fix": apply Prettier formatting
    [x] EditorConfig (.editorconfig) for cross-editor consistency

[x] Zod installation and startup validation (AD-008)
    [x] Add zod dependency to @ctview/core
    [x] Create config schema (packages/core/src/config.ts)
        - DATABASE_DIALECT: z.enum(['sqlite', 'postgres']).default('sqlite')
        - DATABASE_URL: z.string() with sensible default for sqlite
        - INGEST_API_KEY: z.string().optional()
        - PORT: z.coerce.number().default(3000)
        - LOG_LEVEL: z.enum(['debug','info','warn','error']).default('info')
        - CORS_ALLOW_ORIGIN: z.string().default('') (empty = same-origin only)
        - AUTO_MIGRATE: z.string().default('true').transform(v => v === 'true' || v === '1')
    [x] Validate config at application startup in hooks.server.ts
    [x] Export parsed config type for use across the app
    [x] Fail fast with clear error messages if required env vars are missing

[x] CORS configuration for external API clients (AD-007)
    [x] Read CORS_ALLOW_ORIGIN from validated config
    [x] Implement CORS handling in hooks.server.ts
        - Set Access-Control-Allow-Origin header on all /api/* responses
        - Handle OPTIONS preflight requests for /api/* routes
        - Set Access-Control-Allow-Methods (GET, POST, PUT, DELETE, OPTIONS)
        - Set Access-Control-Allow-Headers (Content-Type, Authorization)
        - When CORS_ALLOW_ORIGIN is empty or unset, do not add CORS headers
          (same-origin only, safe default)
        - When set to '*', allow all origins
        - When set to a specific origin, allow only that origin
    [x] Document CORS configuration in README

[x] Structured API error responses (AD-007)
    [x] Define a standard error response shape used by ALL API routes:
        {
          "error": {
            "code": "VALIDATION_FAILED",
            "message": "Human-readable description",
            "details": [...optional array of specific issues...]
          }
        }
    [x] Define standard success response envelope:
        {
          "data": { ...the actual response payload... },
          "meta": { ...optional pagination, timing, etc... }
        }
    [x] Create a shared API response helper (packages/web/src/lib/server/api.ts)
        - apiSuccess(data, status?) → JSON response with envelope
        - apiError(code, message, details?, status?) → JSON error response
        - Common error codes: VALIDATION_FAILED, NOT_FOUND, UNAUTHORIZED,
          DUPLICATE_IMPORT, INTERNAL_ERROR, RATE_LIMITED
    [x] Refactor existing health and ingest endpoints to use the shared helpers
    [x] Ensure all API routes return Content-Type: application/json

[x] Readiness probe endpoint
    [x] GET /api/v1/ready
        - Checks database connectivity (run a trivial query like SELECT 1)
        - Returns { "data": { "status": "ready" } } with 200 on success
        - Returns { "error": { "code": "NOT_READY", "message": "..." } } with
          503 if DB is unreachable
    [x] Update Docker healthcheck to use /api/v1/ready instead of /api/v1/health
    [x] /health remains a lightweight liveness probe (no DB check)
    [x] /ready is the full readiness probe (confirms DB is accessible)

================================================================================
PHASE 2: INGESTION PIPELINE (COMPLETE)
================================================================================

[x] App-level database tables
    [x] ingest_receipt table (packages/core/src/schema/sqlite/app.ts)
        - receipt_id: text primary key (nanoid)
        - import_id: text FK → import_batch.import_id
        - file_id: text FK → credit_file.file_id
        - payload_sha256: text (SHA-256 hash of the raw JSON payload)
        - entity_counts_json: text (JSON object with row counts per entity type)
        - ingested_at: text (ISO 8601 timestamp)
        - duration_ms: integer (time taken to process)
        - status: text ('success' | 'partial' | 'failed')
        - error_message: text (nullable, populated on failure)
    [x] audit_log table
    [x] app_settings table
    [x] severity column added to generated_insight table
    [x] DDL updated in spec/sql/credittimeline-v1.sql with indexes
    [x] Drizzle Row/Insert types exported from schema/types.ts

[x] Idempotent ingestion
    [x] SHA-256 hash computed via computePayloadHash() in transforms.ts
    [x] Dedup check against ingest_receipt before opening transaction
    [x] Duplicate returns early with success=true, duplicate=true
    [x] Non-duplicate proceeds with full ingestion + receipt on completion

[x] Two-phase validation
    [x] Phase 1 — Schema validation (Ajv, already implemented)
    [x] Phase 2 — Referential integrity validation (referential-checks.ts)
        - source_import_id resolution across all entity arrays
        - address_id resolution (associations, links, electoral, searches, etc.)
        - organisation_id resolution (tradelines, searches)
        - Period format validation (YYYY-MM regex)
        - Duplicate metric key detection (using deriveMetricValueKey)
    [x] Quality warnings (non-fatal, quality-warnings.ts)
        - 7 rules: sparse_file, missing_snapshots, missing_metrics,
          negative_balance, zero_credit_limit, duplicate_looking_tradeline
        - Warnings returned in API response AND stored as generated_insight rows

[x] Full ingestion orchestrator (ingest-file.ts)
    [x] Deterministic FK-ordered insert (31 tables)
    [x] Atomic transaction wrapper (all-or-nothing via db.transaction())
    [x] 6 inserter modules in packages/core/src/ingestion/inserters/:
        - provenance.ts (subject, credit_file, import_batch, raw_artifact)
        - identity.ts (person_name, subject_identifier, address,
          address_association, address_link, financial_associate,
          electoral_roll_entry)
        - tradelines.ts (organisation, tradeline + all 6 child entities)
        - records.ts (search, score, public_record, notice, property,
          gone_away, fraud_marker, attributable_item, dispute)
        - insights.ts (generated_insight + generated_insight_entity)
        - app.ts (ingest_receipt, audit_log)
    [x] IngestContext pattern for shared state across inserters
    [x] sourceSystemByImportId map for deriving source_system on child entities
    [x] boolToInt/toJsonText transforms for SQLite type mapping

[x] Canonical types expanded (types/canonical.ts)
    [x] ~25 interfaces matching all JSON Schema $defs
    [x] Tradeline child types (identifier, party, terms, snapshot, metric, event)
    [x] All top-level entity arrays on CreditFile

[x] Referential integrity checks (validation/referential-checks.ts)
    [x] source_import_id resolution
    [x] Address/organisation FK resolution
    [x] Period format validation
    [x] Duplicate metric detection
[x] derive-metric-key.ts (already fully implemented in Phase 1)
[x] Provenance tracking
    [x] source_system and acquisition_method recorded per import batch
    [x] Entity row counts tracked in ingest_receipt.entity_counts_json
[x] Integration tests (24 tests across 3 files, all passing)
    [x] Test successful full ingest (all entity types) — ingest-file.test.ts
    [x] Test idempotent re-ingest (duplicate=true) — ingest-file.test.ts
    [x] Test schema validation rejection — ingest-file.test.ts
    [x] Test referential integrity rejection — ingest-file.test.ts
    [x] Test transaction rollback on duplicate PK — ingest-file.test.ts
    [x] Test quality warnings generated and stored — ingest-file.test.ts
    [x] Test entity counts in ingest_receipt — ingest-file.test.ts
    [x] Test tradeline child entity insertion — ingest-file.test.ts
    [x] 7 referential check unit tests — referential-checks.test.ts
    [x] 9 derive-metric-key unit tests — derive-metric-key.test.ts
[x] Error handling (schema errors, ref integrity errors, transaction rollback)

================================================================================
PHASE 3: QUERY LAYER & API ENDPOINTS (COMPLETE)
================================================================================

All query functions live in @ctview/core (packages/core/src/queries/) as pure
synchronous functions that accept db: AppDatabase. Both page load functions
(+page.server.ts) and API routes (+server.ts) call the same logic, ensuring
feature parity per AD-007. Pagination via Zod-validated limit/offset params.
103 tests passing across 11 test files.

[x] Prerequisite: Drizzle relational query API enabled (relations in schema)
[x] Shared types and helpers (queries/types.ts, queries/helpers.ts)
    [x] PaginatedResult<T> interface, paginationSchema
    [x] Domain-specific Zod filter schemas
    [x] DTOs for all query domains
    [x] parseJsonColumn(), paginate() helpers
[x] Dashboard queries (queries/dashboard.ts)
    [x] Total counts by entity type
    [x] Latest credit score per agency
    [x] Total debt summary (sum of current balances)
    [x] Recent imports list
    [x] GET /api/v1/dashboard — returns all dashboard data in one call
    [x] Dashboard page refactored to use getDashboard()
[x] Subject queries (queries/subjects.ts)
    [x] Subject summary (active tradelines count, public records count,
        fraud marker count, latest score, last import date)
    [x] GET /api/v1/subjects — list subjects
    [x] GET /api/v1/subjects/:subjectId/summary — subject metrics
[x] Tradeline queries (queries/tradelines.ts)
    [x] List all tradelines with latest snapshot
    [x] Tradeline detail with full history
    [x] Monthly metric time series for charting
    [x] Cross-agency comparison for same account (via canonical_id)
    [x] GET /api/v1/tradelines — list tradelines
    [x] GET /api/v1/tradelines/:tradelineId — tradeline detail + history
    [x] GET /api/v1/tradelines/:tradelineId/metrics — time series data
    [x] Tradeline detail page placeholder (+page.svelte for Phase 5)
[x] Search queries (queries/searches.ts)
    [x] Search timeline (hard vs soft over time)
    [x] Search frequency analysis
    [x] GET /api/v1/searches — list searches with filtering
[x] Score queries (queries/scores.ts)
    [x] Score trend over time per agency
    [x] Score comparison across agencies
    [x] GET /api/v1/scores — score history
[x] Import queries (queries/imports.ts)
    [x] Import detail (what was added/changed, entity counts from receipt)
    [x] Diff between two imports
    [x] GET /api/v1/imports — list imports with metadata
    [x] GET /api/v1/imports/:importId — import detail with entity counts
[x] Address queries (queries/addresses.ts)
    [x] Address history with associations
    [x] Electoral roll entries by address
    [x] GET /api/v1/addresses — address history
[x] Anomaly/insight queries (queries/insights.ts)
    [x] GET /api/v1/insights — list generated insights with filtering
    [x] GET /api/v1/subjects/:subjectId/anomalies — per-subject anomalies
[x] Barrel exports (queries/index.ts, core/src/index.ts updated)
[x] 79 new query tests (8 test files, 103 total with ingestion tests)

================================================================================
PHASE 4: UI - DASHBOARD & CHARTS
================================================================================

[ ] Design system and theme tokens
    [ ] Define a named color palette in Tailwind config (semantic names):
        - canvas: page background (warm neutral, e.g. stone-50 or a custom off-white)
        - ink: primary text color (near-black)
        - accent: interactive elements, active states (teal/emerald family)
        - ember: alerts, warnings, destructive actions (orange/red family)
        - soft: subtle borders, dividers, muted backgrounds
        - surface: card/panel backgrounds (white or very light)
        - muted: secondary text, placeholder text
    [ ] Choose and configure a typographic scale
        - Consider a clean sans-serif for UI (Inter, IBM Plex Sans, or similar)
        - Monospace font for financial figures and IDs (IBM Plex Mono, JetBrains
          Mono, or similar)
        - Configure in Tailwind via fontFamily extension
    [ ] Create reusable CSS utility classes or Svelte components for:
        - .panel (card/container with consistent padding, border, radius)
        - Status badge variants (active, closed, default, warning, error)
        - Financial figure display (right-aligned, monospace, pence→pounds)
    [ ] Document the design system in a brief reference (even just a comment
        block in the Tailwind config) so future sessions maintain consistency

[ ] Dashboard page
    [ ] Credit score gauge component
    [ ] Score trend line chart (ECharts)
    [ ] Debt summary cards
    [ ] Recent imports timeline
    [ ] Alert cards (anomalies, changes)
[ ] Shared components
    [ ] MoneyDisplay (pence -> formatted GBP)
    [ ] DateDisplay (date formatting)
    [ ] AgencyBadge (Equifax/TransUnion/Experian)
    [ ] StatusBadge (payment status with color coding)
    [ ] StatCard (KPI display)
    [ ] DataTable (sortable, filterable via TanStack)

================================================================================
PHASE 5: UI - TRADELINE VIEWS
================================================================================

[ ] Tradeline list page
    [ ] Filterable table (by type, status, agency)
    [ ] Account type badges
    [ ] Balance/limit columns with formatting
[ ] Tradeline detail page
    [ ] Account summary card
    [ ] Payment history grid (monthly status heatmap)
    [ ] Balance over time chart
    [ ] Credit limit over time chart
    [ ] Utilization ratio chart (balance/limit)
    [ ] Snapshot comparison table
    [ ] Event timeline
    [ ] Cross-agency data comparison

================================================================================
PHASE 6: UI - REMAINING SECTIONS
================================================================================

[ ] Searches page
    [ ] Timeline view (hard/soft markers)
    [ ] Search frequency chart
    [ ] Organisation search breakdown
[ ] Scores page
    [ ] Multi-agency score chart
    [ ] Score factor display
    [ ] Historical comparison
[ ] Imports page
    [ ] Import list with metadata (source system, entity counts from receipt)
    [ ] Import detail (entities added per import, pulled from ingest_receipt)
    [ ] Manual file upload UI for ingest endpoint
[ ] Addresses page
    [ ] Address history cards
    [ ] Electoral roll display
    [ ] Address link visualization
[ ] Public records page
    [ ] CCJ/IVA/DRO display
    [ ] Status tracking
[ ] Settings page
    [ ] Database info (dialect, path/connection, schema version, row counts)
    [ ] API key management
        - Display whether INGEST_API_KEY is configured (mask the value)
        - Provide a "test ingest" button that sends a minimal payload to
          verify the key works
        - Display CORS configuration status (what origins are allowed)
    [ ] App settings management (read/write from app_settings table)
        - Display preferences (date format, currency format)
        - Anomaly detection thresholds (configurable sensitivity)
        - Notification preferences (if notification system exists)
    [ ] Export functionality (see Phase 9)
    [ ] System health summary (last ingest, DB size, total records)

================================================================================
PHASE 7: ANALYSIS & INSIGHTS
================================================================================

[ ] Anomaly detection rule engine
    [ ] Design a pluggable rule architecture:
        - Each rule is a function: (db, importContext) → InsightResult[]
        - Rules run automatically after successful ingestion
        - Each rule returns zero or more generated_insight records
        - Rules are registered in a central array and executed sequentially
        - New rules can be added without modifying the orchestrator
    [ ] Severity classification for all generated insights:
        - info: Informational, no action needed (e.g. "new tradeline opened")
        - low: Minor observation (e.g. "address changed between imports")
        - medium: Warrants attention (e.g. "hard search from unknown org")
        - high: Requires investigation (e.g. "large unexpected balance jump",
          "payment status degraded to default")
    [ ] Entity linking for all insights:
        - Every generated_insight links to the relevant entities via
          generated_insight_entity join table
        - Enables "show me all anomalies for this tradeline" queries

[ ] Core anomaly rules
    [ ] Hard search detection
        - Flag hard searches appearing since last import
        - Classify by frequency: occasional (low), frequent (medium),
          burst pattern (high)
        - Cross-reference search organisation against known tradeline lenders
          to distinguish expected searches (you applied) from unexpected ones
    [ ] Payment status degradation
        - Compare tradeline payment_status between consecutive snapshots
        - Flag any worsening (e.g. current → 1-month-late → 3-months-late)
        - Severity scales with degradation magnitude
    [ ] Unexpected balance changes
        - Flag balance increases/decreases that exceed a configurable threshold
          percentage between consecutive snapshots
        - Useful for spotting unauthorized charges or data errors
    [ ] New tradeline detection
        - Flag tradelines appearing for the first time in an import
        - Distinguish between expected (new account) and unexpected
    [ ] Status changes
        - Flag tradeline status transitions (active → settled, active → default)
        - Credit score movements exceeding threshold
    [ ] Cross-agency discrepancy detection
        - Compare tradeline data reported by different agencies for the same
          account (matched via canonical_id)
        - Flag material differences in balance, limit, or status

[ ] Trend analysis
    [ ] Debt-to-income trend (if income data available)
    [ ] Credit utilization trend
    [ ] Score movement correlation with account events
[ ] Generated insights pipeline
    [ ] Quality warnings (missing data, sparse imports)
    [ ] Cross-agency comparison insights
    [ ] Payment pattern analysis

================================================================================
PHASE 8: POSTGRES SUPPORT
================================================================================

[ ] Create parallel Drizzle schema (packages/core/src/schema/pg/)
[ ] Dialect-switching database factory
[ ] Postgres-specific migration runner
[ ] Test full pipeline against Postgres
[ ] Update Docker compose for production Postgres usage

================================================================================
PHASE 9: POLISH & PRODUCTION
================================================================================

[ ] API documentation — OpenAPI spec (AD-007)
    [ ] Generate an OpenAPI 3.1 specification for all /api/v1/* routes
    [ ] Options for generation:
        - Manual: maintain a spec/openapi.yaml file updated as routes change
        - Auto: use a library to generate spec from route definitions (e.g.
          sveltekit-openapi or a custom Zod-to-OpenAPI pipeline)
    [ ] Serve the OpenAPI spec at GET /api/v1/openapi.json
    [ ] Optionally serve Swagger UI or Scalar at /api/docs for interactive
        API exploration
    [ ] The spec should be accurate enough that external clients can generate
        typed client code from it

[ ] Client SDK package (AD-007)
    [ ] Create @ctview/sdk package in the monorepo
    [ ] Lightweight TypeScript HTTP client wrapping all /api/v1/* endpoints
    [ ] Type-safe request/response types (shared with or generated from the
        API's Zod schemas)
    [ ] Zero runtime dependencies beyond fetch (works in Node, browser, Deno)
    [ ] Publish as npm package (or just use via workspace dependency)
    [ ] This enables external TypeScript consumers to integrate without
        hand-crafting HTTP calls

[ ] Authentication (optional, for multi-user households)
[ ] Data export (JSON, CSV)
    [ ] Export full credit file as JSON (reversible, re-importable)
    [ ] Export tradeline/search/score data as CSV
    [ ] Export dashboard as printable HTML or PDF
[ ] Backup/restore tooling
    [ ] SQLite: file-level backup with VACUUM INTO for consistent snapshots
    [ ] Postgres: pg_dump wrapper
    [ ] Restore command with validation
[ ] Rate limiting on ingestion endpoint
[ ] Comprehensive error pages
[ ] Mobile-responsive layout
[ ] Performance optimization (pagination, lazy loading)
[ ] Accessibility audit (WCAG 2.1 AA)
[ ] End-to-end Playwright test suite
[ ] CI/CD pipeline (GitHub Actions)
    [ ] Lint + format check
    [ ] Type check (svelte-check + tsc)
    [ ] Unit tests (vitest)
    [ ] E2E tests (playwright)
    [ ] Docker build verification
    [ ] Automated release tagging
[ ] User documentation (setup guide, API guide, troubleshooting)
[ ] Data retention policies
    [ ] Configurable max age for raw artifacts
    [ ] Archive vs. delete semantics
    [ ] Compact old audit_log entries

================================================================================
FUTURE IDEAS (UNSCHEDULED)
================================================================================

- CLI tool for importing credit reports from command line
  (this is a key motivator for @ctview/core being framework-independent)
- Browser extension for scraping credit reports directly
- PDF parser adapter (Equifax statutory report)
- HTML scraper adapter (TransUnion via ClearScore)
- Notification system (email/webhook on score changes)
- Multi-subject support (household members)
- Plugin system for custom analysis
- Mobile app consuming the API (AD-007 ensures API is ready for this)
- Import diff view: side-by-side comparison showing what changed between
  two consecutive imports for the same subject (new tradelines, closed
  accounts, balance movements, score changes)
- GraphQL layer alongside REST (for clients that prefer it)
- Webhook system: push notifications to external URLs when anomalies are
  detected or new imports are processed
